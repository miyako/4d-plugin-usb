/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : LIBUSB
 #	author : miyako
 #	2015/08/20
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

std::mutex globalMutex; /* userInfos,ArrivedEventCallbackHandle,DetachedEventCallbackHandle */
std::mutex globalMutex1;/* for METHOD_PROCESS_ID */
std::mutex globalMutex2;/* for LISTENER_METHOD */
std::mutex globalMutex3;/* PROCESS_SHOULD_TERMINATE */
std::mutex globalMutex4;/* PROCESS_SHOULD_RESUME */

std::mutex globalMutex_LIBUSB_IS_READY;
std::mutex globalMutex_LIBUSB_HOTPLUG_IS_READY;
std::mutex globalMutex_LIBUSB_DEVICE_LIST;
std::mutex globalMutex_HOTPLUG_CONTEXT;

namespace LIBUSB
{
    typedef struct {
        int event;
        int vendor;
        int product;
    }ctx;

    //constants
    process_stack_size_t STACK_SIZE = 0;
    process_name_t PROCESS_NAME = (PA_Unichar *)"$\0U\0S\0B\0_\0H\0O\0T\0P\0L\0U\0G\0\0\0";
    
    //context management
    bool LIBUSB_IS_READY = FALSE;
    bool LIBUSB_HOTPLUG_IS_READY = FALSE;
    std::vector<ctx>userInfos;

    //callback management
    C_TEXT LISTENER_METHOD;
    process_number_t METHOD_PROCESS_ID = 0;
    bool PROCESS_SHOULD_TERMINATE = false;
    bool PROCESS_SHOULD_RESUME = false;
    
    libusb_hotplug_callback_handle ArrivedEventCallbackHandle, DetachedEventCallbackHandle;
    libusb_context *HOTPLUG_CONTEXT = NULL;
    libusb_device **LIBUSB_DEVICE_LIST = NULL;
}

#pragma mark -

void generateUuid(C_TEXT &returnValue) {
    
#if VERSIONMAC
#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
    returnValue.setUTF16String([[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#else
    CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);
    NSString *uuid_str = (NSString *)CFUUIDCreateString(kCFAllocatorDefault, uuid);
    returnValue.setUTF16String([uuid_str stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#endif
#else
    RPC_WSTR str;
    UUID uuid;
    int len;
    wchar_t *buffer;
    if(UuidCreate(&uuid) == RPC_S_OK){
        if(UuidToString(&uuid, &str)==RPC_S_OK){
            len = (wcslen((const wchar_t *)str)*2)+2;
            buffer = (wchar_t *)malloc(len);if(buffer){
                memset(buffer,0x00, len);
                memcpy(buffer, str, len);
                _wcsupr((wchar_t *)buffer);
                CUTF16String uid = (const PA_Unichar *)buffer;
                returnValue.setUTF16String(&uid);
                free(buffer);
            }
            RpcStringFree(&str);
        }
    }
#endif
}

#pragma mark -

bool IsProcessOnExit() {
    
    C_TEXT name;
    PA_long32 state, time;
    PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
    CUTF16String procName(name.getUTF16StringPtr());
    CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
    return (!procName.compare(exitProcName));
}

void OnStartup() {
    
    if(LIBUSB_SUCCESS == libusb_init(NULL)) {
        
        printf("libusb_init: default context\n");
        
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex_LIBUSB_IS_READY);
            
            LIBUSB::LIBUSB_IS_READY = true;
        }
        
        if(libusb_has_capability(LIBUSB_CAP_HAS_HOTPLUG)) {
            
            int status = 0;
            
            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex_HOTPLUG_CONTEXT);
                
                status = libusb_init(&LIBUSB::HOTPLUG_CONTEXT);
            }
            
            if(LIBUSB_SUCCESS == status) {
                
                printf("libusb_init: hotplug context\n");
                
                if(1)
                {
                    std::lock_guard<std::mutex> lock(globalMutex_LIBUSB_HOTPLUG_IS_READY);
                    
                    LIBUSB::LIBUSB_HOTPLUG_IS_READY = true;
                }
                
            }
            printf("LIBUSB_CAP_HAS_HOTPLUG:YES\n");
        }else{
            printf("LIBUSB_CAP_HAS_HOTPLUG:NO\n");
        }
        if(libusb_has_capability(LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER)){
            printf("LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER:YES\n");
        }else{
            printf("LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER:NO\n");
        }
    }
    
}

void OnCloseProcess(){
    
    if(LIBUSB::LIBUSB_IS_READY){
        if(IsProcessOnExit()){
            close_all_device_handles();
            libusb_exit(NULL);
            printf("libusb_exit\n");
            LIBUSB::LIBUSB_IS_READY = false;
            if(LIBUSB::LIBUSB_HOTPLUG_IS_READY) {
                
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)listenerLoopFinish, NULL);
                
                libusb_exit(LIBUSB::HOTPLUG_CONTEXT);
                    
                if(1)
                {
                    std::lock_guard<std::mutex> lock(globalMutex_LIBUSB_HOTPLUG_IS_READY);
                    
                    LIBUSB::LIBUSB_HOTPLUG_IS_READY = false;
                }
                
                
            }
        }
    }
}

#pragma mark -

static int LIBUSB_CALL hotplug_callback(libusb_context *ctx, libusb_device *dev, libusb_hotplug_event event, void *user_data)
{
    struct libusb_device_descriptor desc;
    int libusb_error = libusb_get_device_descriptor(dev, &desc);
    if (libusb_error == LIBUSB_SUCCESS){
        
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex);
            
            LIBUSB::ctx userInfo = {event, desc.idVendor, desc.idProduct};
            
            LIBUSB::userInfos.push_back(userInfo);
        }

    }
    return 0;
}

#pragma mark -

void listenerLoop() {
    
    if(1)
    {
         std::lock_guard<std::mutex> lock(globalMutex3);

        LIBUSB::PROCESS_SHOULD_TERMINATE = false;
    }
    
    /* Current process returns 0 for PA_NewProcess */
    PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();
    
    while(!PA_IsProcessDying())
    {
        PA_YieldAbsolute();
        
        bool PROCESS_SHOULD_RESUME;
        bool PROCESS_SHOULD_TERMINATE;
        
        if(1)
        {
            PROCESS_SHOULD_RESUME = LIBUSB::PROCESS_SHOULD_RESUME;
            PROCESS_SHOULD_TERMINATE = LIBUSB::PROCESS_SHOULD_TERMINATE;
        }
        
        
        if(PROCESS_SHOULD_RESUME)
        {
            size_t userInfos;
            
            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex);
                
                userInfos = LIBUSB::userInfos.size();
            }
            
            while(userInfos)
            {
                PA_YieldAbsolute();
                
                if(CALLBACK_IN_NEW_PROCESS)
                {
                    C_TEXT processName;
                    generateUuid(processName);
                    PA_NewProcess((void *)listenerLoopExecuteMethod,
                                                LIBUSB::STACK_SIZE,
                                                (PA_Unichar *)processName.getUTF16StringPtr());
                }else
                {
                    listenerLoopExecuteMethod();
                }
                
                if (PROCESS_SHOULD_TERMINATE)
                    break;
                
                if(1)
                {
                    std::lock_guard<std::mutex> lock(globalMutex);
                    
                    userInfos = LIBUSB::userInfos.size();
                    PROCESS_SHOULD_TERMINATE = LIBUSB::PROCESS_SHOULD_TERMINATE;
                }
            }
            
            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex4);
                
                LIBUSB::PROCESS_SHOULD_RESUME = false;
            }
            
        }else
        {
            /* DELAY PROCESS does not work for PA_NewProcess */
            PA_PutProcessToSleep(currentProcessNumber, CALLBACK_SLEEP_TIME);
        }
            
        if(1)
        {
            PROCESS_SHOULD_TERMINATE = LIBUSB::PROCESS_SHOULD_TERMINATE;
        }
        
        if (PROCESS_SHOULD_TERMINATE)
            break;
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex);
        
        LIBUSB::userInfos.clear();
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex2);
        
        LIBUSB::LISTENER_METHOD.setUTF16String((PA_Unichar *)"\0\0", 0);
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex1);
        
        LIBUSB::METHOD_PROCESS_ID = 0;
    }

    PA_KillProcess();
}

void listenerLoopStart() {
    
    if(!LIBUSB::METHOD_PROCESS_ID)
    {
        std::lock_guard<std::mutex> lock(globalMutex1);
        
        LIBUSB::METHOD_PROCESS_ID = PA_NewProcess((void *)listenerLoop,
                                                       LIBUSB::STACK_SIZE,
                                                       LIBUSB::PROCESS_NAME);
        
        PA_NewProcess((void *)listenerLoopServer, LIBUSB::STACK_SIZE, (PA_Unichar *)"$\0U\0S\0B\0\0\0");
        
        int product_id, vendor_id, class_id;
        vendor_id  = LIBUSB_HOTPLUG_MATCH_ANY;
        product_id = LIBUSB_HOTPLUG_MATCH_ANY;
        class_id   = LIBUSB_HOTPLUG_MATCH_ANY;
        
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex);
            
            LIBUSB::ArrivedEventCallbackHandle = NULL;
            LIBUSB::DetachedEventCallbackHandle = NULL;
            
            if(LIBUSB_SUCCESS == libusb_hotplug_register_callback(LIBUSB::HOTPLUG_CONTEXT,
                                                                  (libusb_hotplug_event)LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED,
                                                                  (libusb_hotplug_flag)0,
                                                                  vendor_id,
                                                                  product_id,
                                                                  class_id,
                                                                  (libusb_hotplug_callback_fn)hotplug_callback,
                                                                  (void *)NULL,
                                                                  (libusb_hotplug_callback_handle *)&LIBUSB::ArrivedEventCallbackHandle)){
                printf("libusb_hotplug_register_callback(LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED)\n");
            }
            
            if(LIBUSB_SUCCESS == libusb_hotplug_register_callback(LIBUSB::HOTPLUG_CONTEXT,
                                                                  (libusb_hotplug_event)LIBUSB_HOTPLUG_EVENT_DEVICE_LEFT,
                                                                  (libusb_hotplug_flag)0,
                                                                  vendor_id,
                                                                  product_id,
                                                                  class_id,
                                                                  (libusb_hotplug_callback_fn)hotplug_callback,
                                                                  (void *)NULL,
                                                                  (libusb_hotplug_callback_handle *)&LIBUSB::DetachedEventCallbackHandle)){
                printf("libusb_hotplug_register_callback(LIBUSB_HOTPLUG_EVENT_DEVICE_LEFT)\n");
            }
        }
    }
}

void listenerLoopFinish() {
    
    if(LIBUSB::METHOD_PROCESS_ID)
    {
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex3);
            
            LIBUSB::PROCESS_SHOULD_TERMINATE = true;
        }

        PA_YieldAbsolute();
        
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex4);
            
            LIBUSB::PROCESS_SHOULD_RESUME = true;
        }
        
        //uninstall handler
        if(LIBUSB::DetachedEventCallbackHandle){
            libusb_hotplug_deregister_callback(LIBUSB::HOTPLUG_CONTEXT, LIBUSB::DetachedEventCallbackHandle);
            printf("libusb_hotplug_deregister_callback\n");
            LIBUSB::DetachedEventCallbackHandle = NULL;
        }
    }
}

void listenerLoopExecute() {
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex3);
        
        LIBUSB::PROCESS_SHOULD_TERMINATE = false;
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex4);
        
        LIBUSB::PROCESS_SHOULD_RESUME = true;
    }
    
}

void listenerLoopExecuteMethod() {
    
    LIBUSB::ctx userInfo;

    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex);

        std::vector<LIBUSB::ctx>::iterator p;
        
        p = LIBUSB::userInfos.begin();
        
        userInfo = *p;
        
        LIBUSB::userInfos.erase(p);
    }
    
    method_id_t methodId = PA_GetMethodID((PA_Unichar *)LIBUSB::LISTENER_METHOD.getUTF16StringPtr());
    
    if(methodId)
    {
        PA_Variable    params[3];
        params[0] = PA_CreateVariable(eVK_Longint);
        params[1] = PA_CreateVariable(eVK_Longint);
        params[2] = PA_CreateVariable(eVK_Longint);
        
        PA_SetLongintVariable(&params[0], userInfo.event);
        PA_SetLongintVariable(&params[1], userInfo.vendor);
        PA_SetLongintVariable(&params[2], userInfo.product);
                
        PA_ExecuteMethodByID(methodId, params, 3);
        
        PA_ClearVariable(&params[0]);
        PA_ClearVariable(&params[1]);
        PA_ClearVariable(&params[2]);
        
    }else
    {
        PA_Variable    params[4];
        params[1] = PA_CreateVariable(eVK_Longint);
        params[2] = PA_CreateVariable(eVK_Longint);
        params[3] = PA_CreateVariable(eVK_Longint);

        PA_SetLongintVariable(&params[1], userInfo.event);
        PA_SetLongintVariable(&params[2], userInfo.vendor);
        PA_SetLongintVariable(&params[3], userInfo.product);
                
        params[0] = PA_CreateVariable(eVK_Unistring);
        PA_Unistring method = PA_CreateUnistring((PA_Unichar *)LIBUSB::LISTENER_METHOD.getUTF16StringPtr());
        PA_SetStringVariable(&params[0], &method);
        
        /* execute method */
        PA_ExecuteCommandByID(1007, params, 4);

        PA_ClearVariable(&params[0]);
        PA_ClearVariable(&params[1]);
        PA_ClearVariable(&params[2]);
        PA_ClearVariable(&params[3]);
    }
}

void listenerLoopServer() {
    
    timeval tv;
    tv.tv_sec = 0;
    tv.tv_usec = 100000;
    //listen for 0.1 secs, sleep for 0.9 secs
    
    bool PROCESS_SHOULD_TERMINATE = false;
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex3);
        
        PROCESS_SHOULD_TERMINATE = LIBUSB::PROCESS_SHOULD_TERMINATE;
    }
    
    while(!PROCESS_SHOULD_TERMINATE) {
        
        PA_YieldAbsolute();
        
        int LISTENER_METHOD_COMPLETED;
        
        if(0 > libusb_handle_events_timeout_completed(LIBUSB::HOTPLUG_CONTEXT, &tv, &LISTENER_METHOD_COMPLETED)){
            break;
        }
        
        if(PROCESS_SHOULD_TERMINATE){
            break;
            
        }else{
            PA_PutProcessToSleep(PA_GetCurrentProcessNumber(), 54);
            PA_YieldAbsolute();
        }
        
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex3);
            
            PROCESS_SHOULD_TERMINATE = LIBUSB::PROCESS_SHOULD_TERMINATE;
        }
    }
    
    PA_KillProcess();
}

#pragma mark -

std::map<uint32_t, LIBUSB_DEVICE_HANDLE> LIBUSB_DEVICE_HANDLES;
std::map<uint32_t, LIBUSB_DEVICE> LIBUSB_DEVICES;

libusb_device *get_device(C_LONGINT &param, C_LONGINT &error){
    uint32_t deviceRef = param.getIntValue();
    libusb_device *device = NULL;
    auto i = LIBUSB_DEVICES.find(deviceRef);
    if(i != LIBUSB_DEVICES.end()){
        LIBUSB_DEVICE d = i->second;
		device = d.device;
	}else{
        error.setIntValue(LIBUSB_ERROR_NO_DEVICE);
    }
    return device;
}

libusb_device_handle *get_device_handle(C_LONGINT &param, C_LONGINT &error){
    uint32_t deviceHandleRef = param.getIntValue();
    libusb_device_handle *deviceHandle = NULL;
    auto i = LIBUSB_DEVICE_HANDLES.find(deviceHandleRef);
    if(i != LIBUSB_DEVICE_HANDLES.end()){
		LIBUSB_DEVICE_HANDLE h = i->second;
        deviceHandle = h.deviceHandle;
	}else{
        error.setIntValue(LIBUSB_ERROR_NO_DEVICE);
    }
    return deviceHandle;
}

void set_alt_setting(C_LONGINT &param_1, C_LONGINT &param_2, C_LONGINT &param_3, C_LONGINT &error){
    error.setIntValue(LIBUSB_ERROR_NO_DEVICE);
    uint32_t deviceHandleRef = param_1.getIntValue();
    int interfaceNumber = param_2.getIntValue();
    int alternateSetting = param_3.getIntValue();
    auto i = LIBUSB_DEVICE_HANDLES.find(deviceHandleRef);
    if(i != LIBUSB_DEVICE_HANDLES.end()){
        int libusb_error = libusb_set_interface_alt_setting(i->second.deviceHandle, interfaceNumber, alternateSetting);
        printf("libusb_set_interface_alt_setting: setting %i of interface %i of handle %i, %s\n",
        alternateSetting,
        interfaceNumber,
        deviceHandleRef,
        libusb_error_name(libusb_error));
        error.setIntValue(libusb_error);
    }
}

void get_configuration(C_LONGINT &param_1, C_LONGINT &param_2, C_LONGINT &error){
    error.setIntValue(LIBUSB_ERROR_NO_DEVICE);
    uint32_t deviceHandleRef = param_1.getIntValue();
    auto i = LIBUSB_DEVICE_HANDLES.find(deviceHandleRef);
    if(i != LIBUSB_DEVICE_HANDLES.end()){
        int configuration;
        int libusb_error = libusb_get_configuration(i->second.deviceHandle, &configuration);
         printf("libusb_get_configuration: handle %i is configuration %i, %s\n",
            deviceHandleRef,
            configuration,
            libusb_error_name(libusb_error));
            error.setIntValue(libusb_error); 
        if(libusb_error == LIBUSB_SUCCESS){
            param_2.setIntValue(configuration);
        }
    }
}

void set_configuration(C_LONGINT &param_1, C_LONGINT &param_2, C_LONGINT &error){
    error.setIntValue(LIBUSB_ERROR_NO_DEVICE);
    uint32_t deviceHandleRef = param_1.getIntValue();
    int configuration = param_2.getIntValue();
    auto i = LIBUSB_DEVICE_HANDLES.find(deviceHandleRef);
    if(i != LIBUSB_DEVICE_HANDLES.end()){
        int libusb_error = libusb_set_configuration(i->second.deviceHandle, configuration);
        printf("libusb_set_configuration: handle %i is configuration %i, %s\n",
            deviceHandleRef,
            configuration,
            libusb_error_name(libusb_error));
            error.setIntValue(libusb_error);
    }
}

void claim_interface(C_LONGINT &param_1, C_LONGINT &param_2, C_LONGINT &error){
    error.setIntValue(LIBUSB_ERROR_NO_DEVICE);
    uint32_t deviceHandleRef = param_1.getIntValue();
    int interfaceNumber = param_2.getIntValue();
    auto i = LIBUSB_DEVICE_HANDLES.find(deviceHandleRef);
    if(i != LIBUSB_DEVICE_HANDLES.end()){
        auto j = find(i->second.claimedInterfaces.begin(), i->second.claimedInterfaces.end(), interfaceNumber);
        if(j == i->second.claimedInterfaces.end()){
            int libusb_error = libusb_claim_interface(i->second.deviceHandle, interfaceNumber);
            printf("libusb_claim_interface: interface %i of handle %i, %s\n",
                interfaceNumber,
                deviceHandleRef,
                libusb_error_name(libusb_error));
                if(libusb_error == LIBUSB_SUCCESS){
                    i->second.claimedInterfaces.push_back(interfaceNumber);
                }
                error.setIntValue(libusb_error);
        }
    }
}

void release_interface(C_LONGINT &param_1, C_LONGINT &param_2, C_LONGINT &error){
    error.setIntValue(LIBUSB_ERROR_NO_DEVICE);
    uint32_t deviceHandleRef = param_1.getIntValue();
    int interfaceNumber = param_2.getIntValue();
    auto i = LIBUSB_DEVICE_HANDLES.find(deviceHandleRef);
    if(i != LIBUSB_DEVICE_HANDLES.end()){
        auto j = find(i->second.claimedInterfaces.begin(), i->second.claimedInterfaces.end(), interfaceNumber);
        if(j != i->second.claimedInterfaces.end()){
            int libusb_error = libusb_release_interface(i->second.deviceHandle, interfaceNumber);
            printf("libusb_release_interface: interface %i of handle %i, %s\n",
            interfaceNumber,
            deviceHandleRef,
            libusb_error_name(libusb_error));
            if(libusb_error == LIBUSB_SUCCESS){
                i->second.claimedInterfaces.erase(j);
            }
            error.setIntValue(libusb_error);
        }
    }
}

uint32_t open_device(C_LONGINT &param, C_LONGINT &error){
    uint32_t deviceHandleRef = 0;
    libusb_device *device = get_device(param, error);
    if(device){
        libusb_device_handle *deviceHandle;
        int libusb_error = libusb_open(device, &deviceHandle);
        if(libusb_error == LIBUSB_SUCCESS){
            deviceHandleRef = 1;
            while (LIBUSB_DEVICE_HANDLES.find(deviceHandleRef) != LIBUSB_DEVICE_HANDLES.end()) {
                deviceHandleRef++;
            }
            LIBUSB_DEVICE_HANDLE h;
            usb_device_interfaces claimedInterfaces;
            h.device = device;
            h.deviceHandle = deviceHandle;
            h.claimedInterfaces = claimedInterfaces;
            h.isOpen = true;
            LIBUSB_DEVICE_HANDLES.insert(std::map<uint32_t, LIBUSB_DEVICE_HANDLE>::value_type(deviceHandleRef, h));
            printf("libusb_open: handle %i\n", deviceHandleRef);
        }else{
            error.setIntValue(libusb_error);
        }
    }
    return deviceHandleRef;
}

uint32_t open_device_with_vid_pid(C_LONGINT &vid, C_LONGINT &pid, C_LONGINT &error){
    uint32_t deviceHandleRef = 0;
    libusb_device_handle *deviceHandle = libusb_open_device_with_vid_pid(NULL, vid.getIntValue(), pid.getIntValue());
    if(deviceHandle){
        deviceHandleRef = 1;
        while (LIBUSB_DEVICE_HANDLES.find(deviceHandleRef) != LIBUSB_DEVICE_HANDLES.end()) {
            deviceHandleRef++;
        }
        LIBUSB_DEVICE_HANDLE h;
        usb_device_interfaces claimedInterfaces;
        h.device = libusb_get_device(deviceHandle);
        h.deviceHandle = deviceHandle;
        h.claimedInterfaces = claimedInterfaces;
        h.isOpen = true;
        LIBUSB_DEVICE_HANDLES.insert(std::map<uint32_t, LIBUSB_DEVICE_HANDLE>::value_type(deviceHandleRef, h));
        printf("libusb_open: handle %i\n", deviceHandleRef);
    }
    
    return deviceHandleRef;
}

void close_device_handle(C_LONGINT &param){
    uint32_t deviceHandleRef = param.getIntValue();
    auto i = LIBUSB_DEVICE_HANDLES.find(deviceHandleRef);
    if(i != LIBUSB_DEVICE_HANDLES.end()){
        //should release all claimed interfaces before closing a device handle
        for(auto j = i->second.claimedInterfaces.begin(); j != i->second.claimedInterfaces.end(); ++j){
            int interfaceNumber = *j;
            int libusb_error = libusb_release_interface(i->second.deviceHandle, interfaceNumber);
            printf("libusb_release_interface: interface %i of handle %i, %s\n",
            interfaceNumber,
            deviceHandleRef,
            libusb_error_name(libusb_error));
        }
        i->second.claimedInterfaces.clear();
        if(i->second.isOpen){
            i->second.isOpen = false;
            libusb_close(i->second.deviceHandle);
            printf("libusb_close: handle %i\n", deviceHandleRef);
        }
	}
}

void close_all_device_handles(){
    
    if(LIBUSB::LIBUSB_DEVICE_LIST){
        
        for(auto i = LIBUSB_DEVICE_HANDLES.begin(); i != LIBUSB_DEVICE_HANDLES.end(); ++i){
            uint32_t deviceHandleRef = i->first;
            //should release all claimed interfaces before closing a device handle
            for(auto j = i->second.claimedInterfaces.begin(); j != i->second.claimedInterfaces.end(); ++j){
                int interfaceNumber = *j;
                if(LIBUSB_SUCCESS == libusb_release_interface(i->second.deviceHandle, interfaceNumber)){
                    printf("libusb_release_interface: %i of %i\n", interfaceNumber, deviceHandleRef);
                }
            }
            i->second.claimedInterfaces.clear();
            if(i->second.isOpen){
                i->second.isOpen = false;
                libusb_close(i->second.deviceHandle);
                printf("libusb_close: handle %i\n", deviceHandleRef);
            }
        }
        
        LIBUSB_DEVICE_HANDLES.clear();
        LIBUSB_DEVICES.clear();
        
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex_LIBUSB_DEVICE_LIST);
            
            libusb_free_device_list(LIBUSB::LIBUSB_DEVICE_LIST, 1);
            printf("libusb_free_device_list\n");
            
            LIBUSB::LIBUSB_DEVICE_LIST = NULL;
        }
    }
}

uint32_t get_device_list(C_LONGINT &error){
    
    uint32_t cnt;
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex_LIBUSB_DEVICE_LIST);
        
        cnt = libusb_get_device_list(NULL, &LIBUSB::LIBUSB_DEVICE_LIST);
    }
    
    if(cnt > 0){
        printf("libusb_get_device_list\n");
        for(int i = 0; i < cnt; ++i){
            struct libusb_device_descriptor desc;
            libusb_device *device = LIBUSB::LIBUSB_DEVICE_LIST[i];
            if(LIBUSB_SUCCESS == libusb_get_device_descriptor(device, &desc)){
                LIBUSB_DEVICE d;
                d.device = device;
                d.vid = desc.idVendor;
                d.pid = desc.idProduct;
                d.deviceRef = i + 1;
                LIBUSB_DEVICES.insert(std::map<uint32_t, LIBUSB_DEVICE>::value_type(i + 1, d));
            }
        }
    }else{
        error.setIntValue(cnt);
        return 0;
    }
    
    return LIBUSB_DEVICES.size();
}

uint16_t get_max_packet_size(libusb_device *device, uint8_t endpoint){
    uint16_t wMaxPacketSize = 0;
    struct libusb_config_descriptor *config;
    if(LIBUSB_SUCCESS == libusb_get_active_config_descriptor(device, &config)){
        for(int i = 0; i < config->bNumInterfaces; ++i){
            const libusb_interface *interface = &config->interface[i];
            for(int j = 0; j < interface->num_altsetting; ++j){
                const libusb_interface_descriptor *interface_descriptor = &interface->altsetting[j];
                for(int k = 0; k < interface_descriptor->bNumEndpoints; ++k){
                    const libusb_endpoint_descriptor *endpoint_descriptor = &interface_descriptor->endpoint[k];
                    if(endpoint_descriptor->bEndpointAddress){
                        wMaxPacketSize = endpoint_descriptor->wMaxPacketSize;
                        break;
                    }
                }
            }
        }
    }
    return wMaxPacketSize;
}

#pragma mark -

void jsonAddIntProperty(CUTF8String &property, const char* name, int value){
    char buf[11];
    sprintf(buf, "%u", (int)value);
    property += (const uint8_t *)"\"";
    property += (const uint8_t *)name;
    property += (const uint8_t *)"\"";
    property += (const uint8_t *)":";
    property += (const uint8_t *)buf;
}

void jsonAddComma(CUTF8String &property){
    property += (const uint8_t *)",";
}

#pragma mark -

usb_enpoint_t get_endpoint_type(int endpoint){
    usb_enpoint_t endpoint_type = USB_ENDPOINT_UNKNOWN;
    unsigned char ep = (unsigned char)endpoint;
    if((ep & LIBUSB_ENDPOINT_DIR_MASK) == LIBUSB_ENDPOINT_OUT){
        endpoint_type = USB_ENDPOINT_OUT;
    }else if((ep  & LIBUSB_ENDPOINT_DIR_MASK) == LIBUSB_ENDPOINT_IN){
         endpoint_type = USB_ENDPOINT_IN;
    }
    return endpoint_type;
}

void libusb_transfer_cb(struct libusb_transfer *transfer){
    user_data_t *user_data = (user_data_t *)transfer->user_data;
    user_data->status = transfer->status;
    
    usb_enpoint_t endpointType = get_endpoint_type(transfer->endpoint);
    
    switch (transfer->status){
        case LIBUSB_TRANSFER_COMPLETED:
            switch (endpointType) {
              case USB_ENDPOINT_IN:
                user_data->data->setBytes(transfer->buffer, transfer->actual_length);
                break;
              default:
                break;
            }
            break;
        default:
            //do nothing
            break;
    }
    libusb_free_transfer(transfer);
}

int usb_transfer(int timeout){
    struct timeval tv;
    tv.tv_sec = 0;
    tv.tv_usec = timeout * 1000;
    int libusb_error = libusb_handle_events_timeout_completed(NULL, &tv, NULL);
    printf("libusb_handle_events_timeout_completed: %s\n", libusb_error_name(libusb_error));
    return libusb_error;
}

#pragma mark Main

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
        case kInitPlugin :
        case kServerInitPlugin :
            OnStartup();
            break;
            
        case kCloseProcess :
            OnCloseProcess();
            break;    
// --- USB

		case 1 :
			USB_SET_HOTPLUG_METHOD(pResult, pParams);
			break;

		case 2 :
			USB_Get_hotplug_method(pResult, pParams);
			break;

		case 3 :
			USB_SET_LOCALE(pResult, pParams);
			break;

		case 4 :
			USB_GET_VERSION(pResult, pParams);
			break;

		case 5 :
			USB_Get_error_description(pResult, pParams);
			break;

		case 6 :
			USB_Get_error_name(pResult, pParams);
			break;

		case 7 :
			USB_GET_DEVICE_LIST(pResult, pParams);
			break;

		case 8 :
			USB_Get_device_descriptor(pResult, pParams);
			break;

		case 9 :
			USB_Get_config_descriptor(pResult, pParams);
			break;

		case 10 :
			USB_Open(pResult, pParams);
			break;

		case 11 :
			USB_CLAIM_INTERFACE(pResult, pParams);
			break;

		case 12 :
			USB_RELEASE_INTERFACE(pResult, pParams);
			break;

		case 13 :
			USB_CLOSE(pResult, pParams);
			break;

		case 14 :
			USB_Get_device(pResult, pParams);
			break;

		case 15 :
			USB_SET_INTERFACE_ALT_SETTING(pResult, pParams);
			break;

		case 16 :
			USB_SET_CONFIGURATION(pResult, pParams);
			break;

		case 17 :
			USB_Get_configuration(pResult, pParams);
			break;

		case 18 :
			USB_Open_device_with_vid_pid(pResult, pParams);
			break;

		case 19 :
			USB_BULK_TRANSFER(pResult, pParams);
			break;

		case 20 :
			USB_Get_bus_number(pResult, pParams);
			break;

		case 21 :
			USB_Get_port_number(pResult, pParams);
			break;

		case 22 :
			USB_Get_device_address(pResult, pParams);
			break;

		case 23 :
			USB_Get_device_speed(pResult, pParams);
			break;

		case 24 :
			USB_CLEAR_HALT(pResult, pParams);
			break;

		case 25 :
			USB_GET_DESCRIPTOR(pResult, pParams);
			break;

		case 26 :
			USB_INTERRUPT_TRANSFER(pResult, pParams);
			break;

	}
}

#pragma mark -

// -------------------------------------- USB -------------------------------------

void USB_SET_HOTPLUG_METHOD(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;

	Param1.fromParamAtIndex(pParams, 1);

    if(LIBUSB::LIBUSB_HOTPLUG_IS_READY){
        Param1.fromParamAtIndex(pParams, 1);
        LIBUSB::LISTENER_METHOD.setUTF16String(Param1.getUTF16StringPtr(), Param1.getUTF16Length());
        
        if(Param1.getUTF16Length()){
            PA_RunInMainProcess((PA_RunInMainProcessProcPtr)listenerLoopStart, NULL);
        }else{
            PA_RunInMainProcess((PA_RunInMainProcessProcPtr)listenerLoopFinish, NULL);
        }
        
    }else{
        Param2.setIntValue(LIBUSB_ERROR_OTHER);
    }

	Param2.toParamAtIndex(pParams, 2);
}

void USB_Get_hotplug_method(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_TEXT returnValue;

    if(LIBUSB::LIBUSB_HOTPLUG_IS_READY){
        LIBUSB::LISTENER_METHOD.setReturn(pResult);
    }else{
        Param1.setIntValue(LIBUSB_ERROR_OTHER);
        returnValue.setReturn(pResult);
    }
	Param1.toParamAtIndex(pParams, 1);
}

void USB_SET_LOCALE(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;

	Param1.fromParamAtIndex(pParams, 1);

    if(LIBUSB::LIBUSB_IS_READY){
        CUTF8String locale;
        Param1.copyUTF8String(&locale);
        Param2.setIntValue(libusb_setlocale((const char *)locale.c_str()));
    }else{
        Param2.setIntValue(LIBUSB_ERROR_OTHER);
    }

	Param2.toParamAtIndex(pParams, 2);
}

void USB_GET_VERSION(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT Param2;
	C_LONGINT Param3;
	C_LONGINT Param4;
	C_TEXT Param5;
	C_TEXT Param6;

    if(LIBUSB::LIBUSB_IS_READY){
        const libusb_version *version;
        version = libusb_get_version();
        Param1.setIntValue(version->major);
        Param2.setIntValue(version->minor);
        Param3.setIntValue(version->micro);
        Param4.setIntValue(version->nano);
        Param5.setUTF8String((const uint8_t *)version->rc, strlen(version->rc));
        Param6.setUTF8String((const uint8_t *)version->describe, strlen(version->describe));
    }

	Param1.toParamAtIndex(pParams, 1);
	Param2.toParamAtIndex(pParams, 2);
	Param3.toParamAtIndex(pParams, 3);
	Param4.toParamAtIndex(pParams, 4);
	Param5.toParamAtIndex(pParams, 5);
	Param6.toParamAtIndex(pParams, 6);
}

void USB_Get_error_description(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_TEXT returnValue;

	Param1.fromParamAtIndex(pParams, 1);

    if(LIBUSB::LIBUSB_IS_READY){
        CUTF8String err_name = (const uint8_t *)libusb_strerror((libusb_error)Param1.getIntValue());
        returnValue.setUTF8String(&err_name);
    }

	returnValue.setReturn(pResult);
}

void USB_Get_error_name(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_TEXT returnValue;

	Param1.fromParamAtIndex(pParams, 1);

    if(LIBUSB::LIBUSB_IS_READY){
        CUTF8String err_name = (const uint8_t *)libusb_error_name(Param1.getIntValue());
        returnValue.setUTF8String(&err_name);
    }

	returnValue.setReturn(pResult);
}

void USB_GET_DEVICE_LIST(sLONG_PTR *pResult, PackagePtr pParams)
{
	ARRAY_LONGINT Param1;
	ARRAY_LONGINT Param2;
	ARRAY_LONGINT Param3;
	C_LONGINT Param4;

	if(LIBUSB::LIBUSB_IS_READY){
        close_all_device_handles();
        if(get_device_list(Param4)){
            Param1.setSize(1);
            Param2.setSize(1);
            Param3.setSize(1);
            for(auto i = LIBUSB_DEVICES.begin(); i != LIBUSB_DEVICES.end(); ++i){
            Param1.appendIntValue(i->second.deviceRef);//1 based
            Param2.appendIntValue(i->second.vid);
            Param3.appendIntValue(i->second.pid);
            }
        }
    }

	Param1.toParamAtIndex(pParams, 1);
	Param2.toParamAtIndex(pParams, 2);
	Param3.toParamAtIndex(pParams, 3);
	Param4.toParamAtIndex(pParams, 4);
}

void USB_Get_device_descriptor(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT Param2;
	C_TEXT returnValue;

	Param1.fromParamAtIndex(pParams, 1);

	if(LIBUSB::LIBUSB_IS_READY){
        libusb_device *device = get_device(Param1, Param2);
        if(device){
            struct libusb_device_descriptor desc;
            int usb_error = libusb_get_device_descriptor(device, &desc);
            if(LIBUSB_SUCCESS == usb_error){
                CUTF8String property = (const uint8_t *)"{";
                jsonAddIntProperty(property, "bLength", desc.bLength);
                jsonAddComma(property);
                jsonAddIntProperty(property, "bDescriptorType", desc.bDescriptorType);
                jsonAddComma(property);
                jsonAddIntProperty(property, "bcdUSB", desc.bcdUSB);
                jsonAddComma(property);
                jsonAddIntProperty(property, "bDeviceClass", desc.bDeviceClass);
                jsonAddComma(property);
                jsonAddIntProperty(property, "bDeviceSubClass", desc.bDeviceSubClass);
                jsonAddComma(property);
                jsonAddIntProperty(property, "bDeviceProtocol", desc.bDeviceProtocol);
                jsonAddComma(property);
                jsonAddIntProperty(property, "bMaxPacketSize0", desc.bMaxPacketSize0);
                jsonAddComma(property);
                jsonAddIntProperty(property, "idVendor", desc.idVendor);
                jsonAddComma(property);
                jsonAddIntProperty(property, "idProduct", desc.idProduct);
                jsonAddComma(property);
                jsonAddIntProperty(property, "bcdDevice", desc.bcdDevice);
                jsonAddComma(property);
                jsonAddIntProperty(property, "iManufacturer", desc.iManufacturer);
                jsonAddComma(property);
                jsonAddIntProperty(property, "iProduct", desc.iProduct);
                jsonAddComma(property);
                jsonAddIntProperty(property, "iSerialNumber", desc.iSerialNumber);
                jsonAddComma(property);
                jsonAddIntProperty(property, "bNumConfigurations", desc.bNumConfigurations);
                property += (const uint8_t *)"}";
                returnValue.setUTF8String(&property);
            }
            Param2.setIntValue(usb_error);
        }
    }

	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void USB_Get_config_descriptor(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT Param2;
	C_LONGINT Param3;
	C_LONGINT Param4;
	C_TEXT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	if(LIBUSB::LIBUSB_IS_READY){
        libusb_device *device = get_device(Param1, Param4);
        if(device){
            struct libusb_config_descriptor *config;
            int libusb_error;
            switch (Param2.getIntValue()){
                case USB_CONFIGURATION_BY_INDEX:
                    libusb_error = libusb_get_config_descriptor(device, Param3.getIntValue(), &config);
                break;
                case USB_CONFIGURATION_BY_VALUE:
                    libusb_error = libusb_get_config_descriptor_by_value(device, Param3.getIntValue(), &config);
                break;
                default:
                    libusb_error = libusb_get_active_config_descriptor(device, &config);
                break;
            }
            if(libusb_error == LIBUSB_SUCCESS){
                CUTF8String property = (const uint8_t *)"{";
                jsonAddIntProperty(property, "bLength", config->bLength);
                jsonAddComma(property);
                jsonAddIntProperty(property, "bDescriptorType", config->bDescriptorType);
                jsonAddComma(property);
                jsonAddIntProperty(property, "wTotalLength", config->wTotalLength);
                jsonAddComma(property);
                jsonAddIntProperty(property, "bNumInterfaces", config->bNumInterfaces);
                jsonAddComma(property);
                jsonAddIntProperty(property, "bConfigurationValue", config->bConfigurationValue);
                jsonAddComma(property);
                jsonAddIntProperty(property, "iConfiguration", config->iConfiguration);
                jsonAddComma(property);
                jsonAddIntProperty(property, "bmAttributes", config->bmAttributes);
                jsonAddComma(property);
                jsonAddIntProperty(property, "MaxPower", config->MaxPower);
                jsonAddComma(property);
                property += (const uint8_t *)"\"interface\":[";
                for(int i = 0; i < config->bNumInterfaces; ++i){
                    if(i) jsonAddComma(property);
                    const libusb_interface *interface = &config->interface[i];
                    property += (const uint8_t *)"{";
                    jsonAddIntProperty(property, "num_altsetting", interface->num_altsetting);
                    jsonAddComma(property);
                    property += (const uint8_t *)"\"altsetting\":[";
                    for(int j = 0; j < interface->num_altsetting; ++j){
                        if(j) jsonAddComma(property);
                        const libusb_interface_descriptor *interface_descriptor = &interface->altsetting[j];
                        property += (const uint8_t *)"{";
                        jsonAddIntProperty(property, "bLength", interface_descriptor->bLength);
                        jsonAddComma(property);
                        jsonAddIntProperty(property, "bDescriptorType", interface_descriptor->bDescriptorType);
                        jsonAddComma(property);
                        jsonAddIntProperty(property, "bInterfaceNumber", interface_descriptor->bInterfaceNumber);
                        jsonAddComma(property);
                        jsonAddIntProperty(property, "bAlternateSetting", interface_descriptor->bAlternateSetting);
                        jsonAddComma(property);
                        jsonAddIntProperty(property, "bNumEndpoints", interface_descriptor->bNumEndpoints);
                        jsonAddComma(property);
                        jsonAddIntProperty(property, "bInterfaceClass", interface_descriptor->bInterfaceClass);
                        jsonAddComma(property);
                        jsonAddIntProperty(property, "bInterfaceSubClass", interface_descriptor->bInterfaceSubClass);
                        jsonAddComma(property);
                        jsonAddIntProperty(property, "bInterfaceProtocol", interface_descriptor->bInterfaceProtocol);
                        jsonAddComma(property);
                        jsonAddIntProperty(property, "iInterface", interface_descriptor->iInterface);
                        jsonAddComma(property);
                        property += (const uint8_t *)"\"endpoint\":[";
                        for(int k = 0; k < interface_descriptor->bNumEndpoints; ++k){
                            if(k) jsonAddComma(property);
                            const libusb_endpoint_descriptor *endpoint_descriptor = &interface_descriptor->endpoint[k];
                            property += (const uint8_t *)"{";
                            jsonAddIntProperty(property, "bLength", endpoint_descriptor->bLength);
                            jsonAddComma(property);
                            jsonAddIntProperty(property, "bDescriptorType", endpoint_descriptor->bDescriptorType);
                            jsonAddComma(property);
                            jsonAddIntProperty(property, "bEndpointAddress", endpoint_descriptor->bEndpointAddress);
                            jsonAddComma(property);
                            jsonAddIntProperty(property, "bmAttributes", endpoint_descriptor->bmAttributes);
                            jsonAddComma(property);
                            jsonAddIntProperty(property, "wMaxPacketSize", endpoint_descriptor->wMaxPacketSize);
                            jsonAddComma(property);
                            jsonAddIntProperty(property, "bInterval", endpoint_descriptor->bInterval);
                            jsonAddComma(property);
                            jsonAddIntProperty(property, "bRefresh", endpoint_descriptor->bRefresh);
                            jsonAddComma(property);
                            jsonAddIntProperty(property, "bSynchAddress", endpoint_descriptor->bSynchAddress);
                            property += (const uint8_t *)"}";
                        }
                        property += (const uint8_t *)"]";
                        property += (const uint8_t *)"}";
                    }
                    property += (const uint8_t *)"]";
                    property += (const uint8_t *)"}";
                }
                property += (const uint8_t *)"]";
                property += (const uint8_t *)"}";
                returnValue.setUTF8String(&property);
                libusb_free_config_descriptor(config);
            }
            Param4.setIntValue(libusb_error);
        }
    }

	Param4.toParamAtIndex(pParams, 4);
	returnValue.setReturn(pResult);
}

void USB_Open(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);

	if(LIBUSB::LIBUSB_IS_READY){
        returnValue.setIntValue(open_device(Param1, Param2));
    }

	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void USB_CLAIM_INTERFACE(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT Param2;
	C_LONGINT Param3;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);

    if(LIBUSB::LIBUSB_IS_READY){
        claim_interface(Param1, Param2, Param3);
    }

	Param3.toParamAtIndex(pParams, 3);
}

void USB_RELEASE_INTERFACE(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT Param2;
	C_LONGINT Param3;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);

    if(LIBUSB::LIBUSB_IS_READY){
        release_interface(Param1, Param2, Param3);
    }

	Param3.toParamAtIndex(pParams, 3);
}

void USB_CLOSE(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;

	Param1.fromParamAtIndex(pParams, 1);

	if(LIBUSB::LIBUSB_IS_READY){
        close_device_handle(Param1);
    }
}

void USB_Get_device(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);

    if(LIBUSB::LIBUSB_IS_READY){
        libusb_device_handle *deviceHandle = get_device_handle(Param1, Param2);
        if(deviceHandle){
            if(!LIBUSB_DEVICES.size()){
                //e.g. if open_with_vid_pid was used
                get_device_list(Param2);
            }
            libusb_device *device = libusb_get_device(deviceHandle);
            for(auto i = LIBUSB_DEVICES.begin(); i != LIBUSB_DEVICES.end(); ++i){
                PA_YieldAbsolute();
                if(i->second.device == device){
                    returnValue.setIntValue(i->first);
                    break;
                }
            }
            if(!returnValue.getIntValue()){
                close_all_device_handles();
                get_device_list(Param2);
                device = libusb_get_device(deviceHandle);
                for(auto i = LIBUSB_DEVICES.begin(); i != LIBUSB_DEVICES.end(); ++i){
                    PA_YieldAbsolute();
                    if(i->second.device == device){
                        returnValue.setIntValue(i->first);
                        break;
                    }
                }
            }            
        }
    }

	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void USB_SET_INTERFACE_ALT_SETTING(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT Param2;
	C_LONGINT Param3;
	C_LONGINT Param4;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);

	if(LIBUSB::LIBUSB_IS_READY){
        set_alt_setting(Param1, Param2, Param3, Param4);
    }

	Param4.toParamAtIndex(pParams, 4);
}

void USB_SET_CONFIGURATION(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT Param2;
	C_LONGINT Param3;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);

	if(LIBUSB::LIBUSB_IS_READY){
        set_configuration(Param1, Param2, Param3);
    }

	Param3.toParamAtIndex(pParams, 3);
}

void USB_Get_configuration(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);

	if(LIBUSB::LIBUSB_IS_READY){
        get_configuration(Param1, returnValue, Param2);
    }

	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void USB_Open_device_with_vid_pid(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT Param2;
	C_LONGINT Param3;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);

    if(LIBUSB::LIBUSB_IS_READY){
        returnValue.setIntValue(open_device_with_vid_pid(Param1, Param2, Param3));
    }

	Param3.toParamAtIndex(pParams, 3);
	returnValue.setReturn(pResult);
}

void USB_Get_bus_number(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);

	if(LIBUSB::LIBUSB_IS_READY){
        libusb_device *device = get_device(Param1, Param2);
        if(device){
            returnValue.setIntValue(libusb_get_bus_number(device));
        }
    }

	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void USB_Get_port_number(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);

	if(LIBUSB::LIBUSB_IS_READY){
        libusb_device *device = get_device(Param1, Param2);
        if(device){
            returnValue.setIntValue(libusb_get_port_number(device));
        }
    }

	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void USB_Get_device_address(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);

	if(LIBUSB::LIBUSB_IS_READY){
        libusb_device *device = get_device(Param1, Param2);
        if(device){
            returnValue.setIntValue(libusb_get_device_address(device));
        }
    }

	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void USB_Get_device_speed(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);

	if(LIBUSB::LIBUSB_IS_READY){
        libusb_device *device = get_device(Param1, Param2);
        if(device){
            returnValue.setIntValue(libusb_get_device_speed(device));
        }
    }

	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void USB_CLEAR_HALT(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT Param2;
	C_LONGINT Param3;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);

    if(LIBUSB::LIBUSB_IS_READY){
        libusb_device_handle *deviceHandle = get_device_handle(Param1, Param3);
        if(deviceHandle){
            Param3.setIntValue(libusb_clear_halt(deviceHandle, (unsigned char)Param2.getIntValue()));
        }
    }
    
	Param3.toParamAtIndex(pParams, 3);
}

void USB_GET_DESCRIPTOR(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT Param2;
	C_LONGINT Param3;
	C_BLOB Param4;
	C_LONGINT Param5;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);

    if(LIBUSB::LIBUSB_IS_READY){
        libusb_device_handle *deviceHandle = get_device_handle(Param1, Param5);
        if(deviceHandle){
            uint8_t desc_type = (uint8_t)Param2.getIntValue();
            uint8_t desc_index = (uint8_t)Param3.getIntValue();
            std::vector<unsigned char>buf(DESCRIPTOR_BUFFER_SIZE);
            int size = libusb_get_descriptor(deviceHandle, desc_type, desc_index, &buf[0], DESCRIPTOR_BUFFER_SIZE);
            if(size > 0){
                Param4.setBytes((const uint8_t *)&buf[0], size);
            }
        }
    }

    Param4.toParamAtIndex(pParams, 4);
	Param5.toParamAtIndex(pParams, 5);
}

#pragma mark Transfer

void USB_INTERRUPT_TRANSFER(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT Param2;
	C_BLOB Param3;
	C_LONGINT Param4;
	C_LONGINT Param5;
	C_LONGINT Param6;
    
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);

    if(LIBUSB::LIBUSB_IS_READY){
        libusb_device_handle *deviceHandle = get_device_handle(Param1, Param6);
        if(deviceHandle){
        
            libusb_device *device = libusb_get_device(deviceHandle);
            unsigned char endpoint = Param2.getIntValue();
            unsigned int timeout = Param4.getIntValue();
            int libusb_error;
            
            user_data_t user_data;
            user_data.data = &Param3;
            user_data.status = 0;
            int length = 0;
            std::vector<unsigned char>buf(0);
            unsigned char *buffer = NULL;
            libusb_transfer *transfer = NULL;
            usb_enpoint_t endpointType = get_endpoint_type(endpoint);
            
            switch (endpointType){
                case USB_ENDPOINT_IN:
                    length = get_max_packet_size(device, endpoint);
                    buf.resize(length);
                    buffer = &buf[0];
                    transfer = libusb_alloc_transfer(0);
                    break;
                case USB_ENDPOINT_OUT:
                    length = Param3.getBytesLength();
                    buffer = (unsigned char *)Param3.getBytesPtr();
                    transfer = libusb_alloc_transfer(0);
                    break;
                default:
                    break;
            }
            
            if(endpointType != USB_ENDPOINT_UNKNOWN){
                libusb_fill_interrupt_transfer(
                        transfer,
                        deviceHandle,
                        endpoint,
                        buffer,
                        length,
                        (libusb_transfer_cb_fn)libusb_transfer_cb,
                        &user_data,
                        timeout);
                
                libusb_error = libusb_submit_transfer(transfer);
                printf("libusb_submit_transfer: endpoint %i of handle %i, %s\n",
                endpoint,
                Param1.getIntValue(),
                libusb_error_name(libusb_error));
                
                if(libusb_error == LIBUSB_SUCCESS){
                    //the application will block anyway, why bother...
                    //blocking
                    libusb_error = usb_transfer(timeout);
                    printf("usb_transfer: %s\n",
                        libusb_error_name(libusb_error));
                    
                    if(libusb_error == LIBUSB_SUCCESS){
                        Param5.setIntValue(user_data.status);
                    }
                }
                Param6.setIntValue(libusb_error);
            }
        }
    }

	Param3.toParamAtIndex(pParams, 3);
	Param5.toParamAtIndex(pParams, 5);
	Param6.toParamAtIndex(pParams, 6);
}


void USB_BULK_TRANSFER(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT Param2;
	C_BLOB Param3;
	C_LONGINT Param4;
	C_LONGINT Param5;
	C_LONGINT Param6;
    
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);

    if(LIBUSB::LIBUSB_IS_READY){
        libusb_device_handle *deviceHandle = get_device_handle(Param1, Param6);
        if(deviceHandle){
        
            libusb_device *device = libusb_get_device(deviceHandle);
            unsigned char endpoint = Param2.getIntValue();
            unsigned int timeout = Param4.getIntValue();
            int libusb_error;
            
            user_data_t user_data;
            user_data.data = &Param3;
            user_data.status = 0;
            int length = 0;
            std::vector<unsigned char>buf(0);
            unsigned char *buffer = NULL;
            libusb_transfer *transfer = NULL;
            usb_enpoint_t endpointType = get_endpoint_type(endpoint);
            
            switch (endpointType){
                case USB_ENDPOINT_IN:
                    length = get_max_packet_size(device, endpoint);
                    buf.resize(length);
                    buffer = &buf[0];
                    transfer = libusb_alloc_transfer(0);
                    break;
                case USB_ENDPOINT_OUT:
                    length = Param3.getBytesLength();
                    buffer = (unsigned char *)Param3.getBytesPtr();
                    transfer = libusb_alloc_transfer(0);
                    break;
                default:
                    break;
            }
            
            if(endpointType != USB_ENDPOINT_UNKNOWN){
                libusb_fill_bulk_transfer(
                        transfer,
                        deviceHandle,
                        endpoint,
                        buffer,
                        length,
                        (libusb_transfer_cb_fn)libusb_transfer_cb,
                        &user_data,
                        timeout);
                
                libusb_error = libusb_submit_transfer(transfer);
                printf("libusb_submit_transfer: endpoint %i of handle %i, %s\n",
                endpoint,
                Param1.getIntValue(),
                libusb_error_name(libusb_error));
                
                if(libusb_error == LIBUSB_SUCCESS){
                    //the application will block anyway, why bother...
                    //blocking
                    libusb_error = usb_transfer(timeout);
                    printf("usb_transfer: %s\n",
                        libusb_error_name(libusb_error));
                    
                    if(libusb_error == LIBUSB_SUCCESS){
                        Param5.setIntValue(user_data.status);
                    }
                }
                Param6.setIntValue(libusb_error);
            }
        }
    }

	Param3.toParamAtIndex(pParams, 3);
	Param5.toParamAtIndex(pParams, 5);
	Param6.toParamAtIndex(pParams, 6);
}
